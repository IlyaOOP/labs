№1 2
наследование--приобретение одним объектм свойств другого
инкапсуляция--преобразование данных в пакеты, защищенные от ввнешнего воздействия 
полиморфизм--способность вызывать метод потомка через экземпляр предка
№3
открытые:
ToString()
GetHashCode()
№4
Finalize()--Вызывается, когда уборщик мусора определяет, что объект является мусором, но до возвращения занятой объектом памяти в кучу. 
№6
атрибуты спецификаторы
№6
С помощью ключевого слова base мы можем обратиться к базовому классу
Модификатор abstract указывает, что изменяемый элемент имеет отсутствующую или неполную реализацию.
Модификатор static используется для объявления статического члена, принадлежащего собственно типу, а не конкретному объекту
public
№7
объект--экземпляр класса
№8
конструктор--набор комманд для инициализации объекта
Конструкторы вызываются при создании нового объекта данного класса. Конструкторы выполняют инициализацию объекта.
№9
не имеет возвращаемого значения
имя такое же как и имя типа (класса) 
не наследуются 
нельзя применять модификаторы virtual, new, override, sealed и abstract 
для класса без явно заданных конструкторов компилятор создает конструктор по умолчанию (без параметров) 
№10
Деструкторы используются для уничтожения экземпляров классов.(метод)
№11
обеспечивает доступ к текущему экземпляру класса
№13
public, private, protected, internal
№14
protected internal: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из 
текущей сборки и из производных классов.
№15
При передаче параметров по ссылке перед параметрами используется модификатор ref
Чтобы сделать параметр выходным, перед ним ставится модификатор out:
№16
Необязательные параметры static int OptionalParam(int x, int y, int z=5, int s=4)
Именованные параметры 
static int OptionalParam(int x, int y, int z=5, int s=4)ХЪ
OptionalParam(y:2, x:3, s:10);
№81
через свойства устанавливается доступ к приватным переменным класса. Подобное сокрытие состояния класса от 
вмешательства извне представляет механизм инкапсуляции
№19
value
№20
тип имя { get; set; }
компилятор автоматически реализует методы для правильного возвращения значения из поля и назначения значения полю
№21
Позволяют индексировать объекты таким же способом, как массив или коллекцию 
№22
один и тот же метод, но с разным набором параметров
№23
Разделение файла или структуры на логические модули 
№24
позволяют создать объект с некоторым набором свойств без определения класса 
№25
чтобы использовать , не создавая экземпляр(math)
№26
Статический метод - вызывается на уровне типа (вызов: Имя_типа точка Имя_метода)
Экземплярный метод - вызывается на уровне объявленного экземпляра типа (вызов: Имя_переменной точка Имя_метода).
№27
Статические конструкторы нельзя вызвать в программе вручную. Они выполняются автоматически при самом первом создании объекта данного класса или первом обращении к его статическим членам (если таковые имеются)
№28
При поверхностном копировании копируются значения полей класса, включая значения любых указателей или ссылок. При этом скопированные значения этих указателей и ссылок указывают на одни и те же объекты, что и в оригинальном объекте, что зачастую ведет к ошибкам. Отсюда и название такого метода копирования: мы копируем только указатели/ссылки, вместо того, чтобы делать копии этих внутренних объектов и ссылаться на них,
собственно не углубляемся во внутреннюю структуру объекта.
При глубоком копировании мы копируем значения полей не только на первом "уровне", но и заходим глубже, копируя все значения.
№29
значчение/ссылка


